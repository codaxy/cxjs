---
layout: ../../../layouts/DocsLayout.astro
title: Typed Models
description: Define type-safe data models with createModel
---

import CodeExample from "../../../components/CodeExample.astro";
import Note from "../../../components/Note.astro";
import TypedModelsExample from "../../../examples/intro/TypedModelsExample.tsx";
import TypedModelsExampleCode from "../../../examples/intro/TypedModelsExample.tsx?raw";
import AccessorMethodsExample from "../../../examples/intro/AccessorMethodsExample.tsx";
import AccessorMethodsExampleCode from "../../../examples/intro/AccessorMethodsExample.tsx?raw";

# Typed Models

CxJS uses **typed models** to provide type-safe access to data in the store. Instead of using string paths like `"user.firstName"`, you use accessor chains like `m.user.firstName` that are checked by TypeScript.

## Creating a Model Proxy

Use `createModel<T>()` to create a proxy object that mirrors your data structure. The proxy doesn't hold any data — it generates binding paths that connect widgets to the store.

<CodeExample code={TypedModelsExampleCode}>
  <TypedModelsExample client:load />
</CodeExample>

When you write `m.user.firstName`, CxJS creates a binding to the path `"user.firstName"` in the store. The TextField reads and writes to this path automatically.

## Why Typed Models?

Typed models provide several benefits over string-based paths:

- **Type safety** — TypeScript catches typos and invalid paths at compile time
- **Autocomplete** — Your editor suggests available properties as you type
- **Refactoring** — Rename a property and all usages update automatically
- **Documentation** — Hover over a property to see its type

## Accessor Methods

Accessor chains provide two useful methods for working with paths:

| Method       | Description                                                                                                               |
| ------------ | ------------------------------------------------------------------------------------------------------------------------- |
| `toString()` | Returns the full string path represented by the accessor. Useful when you need to pass paths to APIs that expect strings. |
| `nameOf()`   | Returns only the last segment of the path (the property name).                                                            |

<CodeExample code={AccessorMethodsExampleCode}>
  <AccessorMethodsExample client:load />
</CodeExample>

## Nested Structures

Accessor chains work with deeply nested structures. Define your interfaces to match your data shape:

```tsx
interface Address {
  street: string;
  city: string;
  country: string;
}

interface User {
  name: string;
  address: Address;
}

interface PageModel {
  user: User;
}

const m = createModel<PageModel>();

// Access nested properties
m.user.address.city; // binds to "user.address.city"
```

The proxy automatically generates the correct path regardless of nesting depth.

<Note>
`createModel` can also be imported from `cx/ui`. `createAccessorModelProxy` is available as an alias for backward compatibility.
</Note>
